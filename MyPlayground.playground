import UIKit

//#1
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func findMaximumSubstring(inputString: String) -> String {
    var maximumSubstring = ""
    let characters = Array(inputString)

    for startIndex in 0..<characters.count {
        for endIndex in (startIndex + 1)..<characters.count {
            let substring = String(characters[startIndex...endIndex])
            let letterCount = substring.filter { $0.isLetter }.count
            let numberCount = substring.filter { $0.isNumber }.count

            if letterCount == numberCount && substring.count > maximumSubstring.count {
                maximumSubstring = substring
            }
        }
    }

    return maximumSubstring
}

let inputString = "1abc1234"
let maximumSubstring = findMaximumSubstring(inputString: inputString)
print(maximumSubstring)


//Пространственная сложность - O(N) - т.к код использует несколько переменных, но их количество не зависит от размера входной строки
//Временная сложность - O(N^3) - т.к  цикл выполняется от 0 до n-1, где n - длина входной строки, внутри цикла создается substring, которая требует  О(endIndex - startIndex + 1), тк цикл выполняетяся для всех комбинаций наччального и конечного индекса, то создает доп множитель О(N) => O(N*N*(N-1)) = O(N^3) - O(N^2) = O(N^3)

//Можно ускорить работу до O(N^2) во временной сложности:
func newFindMaximumSubstring(inputString: String) -> String {
    let characters = Array(inputString)
    let n = characters.count
    var maximumSubstring = ""

    for startIndex in 0..<n {
        var letterCount = 0
        var numberCount = 0

        for endIndex in startIndex..<n {
            let char = characters[endIndex]

            if char.isLetter {
                letterCount += 1
            } else if char.isNumber {
                numberCount += 1
            }

            if letterCount == numberCount && endIndex - startIndex + 1 > maximumSubstring.count {
                maximumSubstring = String(characters[startIndex...endIndex])
            }
        }
    }

    return maximumSubstring
}

let newInputString = "1abc1234"
let newMaximumSubstring = newFindMaximumSubstring(inputString: newInputString)
print(newMaximumSubstring)

//Тут создается infoArrayEqualCharacters (двумерный массив) для хранения информации о равенстве количестве букв и цифр, чтобы избежать потворных вычислений и сократить временную сложность

//#2
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
func mergeArrays(arrays: [[Int]]) -> [Int] {
    guard !arrays.isEmpty else {
        return []
    }

    var sortedArrayResult = arrays[0]

    for i in 1..<arrays.count {
        sortedArrayResult = makeSortedArrays(sortedArrayResult: sortedArrayResult,
                                             compareArraysWithCurrent: arrays[i])
    }

    return sortedArrayResult
}

func makeSortedArrays(sortedArrayResult: [Int], compareArraysWithCurrent: [Int]) -> [Int] {
    var resultArray = [Int]()
    var resultIndex = 0
    var compareIndex = 0

    while resultIndex < sortedArrayResult.count && compareIndex < compareArraysWithCurrent.count {
        if sortedArrayResult[resultIndex] < compareArraysWithCurrent[compareIndex] {
            resultArray.append(sortedArrayResult[resultIndex])
            resultIndex += 1
        } else {
            resultArray.append(compareArraysWithCurrent[compareIndex])
            compareIndex += 1
        }
    }

    while resultIndex < sortedArrayResult.count {
        resultArray.append(sortedArrayResult[resultIndex])
        resultIndex += 1
    }

    while compareIndex < compareArraysWithCurrent.count {
        resultArray.append(compareArraysWithCurrent[compareIndex])
        compareIndex += 1
    }

    return resultArray
}

let arr1 = [7, 7, 7]
let arr2 = [2, 4, 6]
let arr3 = [0, 7, 8]
let arr4 = [4, 6, 9]
let arr5 = [0, 10, 11]
let arr6 = [14, 20, 22]
let arr7 = [11, 15, 21]
let arr8 = [13, 16, 19]

let mergedArray = mergeArrays(arrays: [arr1, arr2, arr3, arr4, arr5, arr6, arr7, arr8])
print(mergedArray)

//Пространственная сложность O(N) - где N суммарная длина всех массивов, где создаестся самый большой массив resultArray который хранит и объединяет результат всех входных массивов
//Временная сложность O(N*M) - где N - количество входных массивов, M - суммарная длина всех входных массив


//Это первое решение, можно сократить время выполнения без вложенных циклов, что позволит сократить время выполнения, но пространственная и временная сложность останутся такими же

func newMergeArrays(arrays: [[Int]]) -> [Int] {
    let count = arrays.reduce(0) { $0 + $1.count }
    if count == 0 {
        return []
    }

    var result = Array(repeating: 0, count: count)
    var indices = Array(repeating: 0, count: arrays.count)

    for i in 0..<count {
        var minIndex = -1
        var minValue = Int.max

        for j in 0..<arrays.count {
            if indices[j] < arrays[j].count && arrays[j][indices[j]] < minValue {
                minIndex = j
                minValue = arrays[j][indices[j]]
            }
        }

        result[i] = minValue
        indices[minIndex] += 1
    }

    return result
}

let mas1 = [7, 7, 7]
let mas2 = [2, 4, 6]
let mas3 = [0, 7, 8]
let mas4 = [4, 6, 9]
let mas5 = [0, 10, 11]
let mas6 = [14, 20, 22]
let mas7 = [11, 15, 21]
let mas8 = [13, 16, 19]

let newMergedArray = newMergeArrays(arrays: [mas1, mas2, mas3, mas4, mas5, mas6, mas7, mas8])
print(mergedArray)


